## 1. Testing
Before you can deploy your code, it will need to be tested. Writing tests is standard practice in software engineering. However, testing is often a practice many data scientists aren't familiar with when they first start in industry. In fact, sometimes the insights data scientists come up with, which are supposed to be used for business decisions and company products, are based on the results of untested code. This lack of testing is a common complaint from other software developers working with data scientists. Without testing, not only do you run into execution errors in code due to software issues, you could also be dictating business decisions and affect products based on faulty conclusions. Today, employers are looking for data scientists with the skills to properly prepare their code for an industry setting, which means tested code. 

## 2. Why testing for data science
It's pretty obvious when a software program crashes. You get an error, and the program stops running. However, there are many problems that could occur in the data science process that aren't as easily detectable as a functional error that crashes your program. All of your code can seem to run smoothly with you completely unaware that certain values will be encoded incorrectly, features are being used inappropriately, or unexpected data were breaking assumptions that your statistical models are based on. These errors are more difficult to find because you have to check for the quality and accuracy of your analysis in addition to the quality of your code. Therefore, it's essential that you had proper testing to avoid unexpected surprises and have confidence in your results. In fact, testing has proven to have so many benefits that there's an entire development process based on it called Test Driven Development. This is a development process where you write test for tasks before you even write the code to implement those tasks. We'll talk more about this later. For now, we will get some practice writing tests, specifically unit test. A unit test is a type of test that covers a unit of code, usually a single function independently from the rest of the program. First, you'll learn how to write unit tests in plain Python, and then how we can use additional tools to make them better. Finally, you'll see examples of types of tests you will see in data science.

## 3. Unit tests
https://www.youtube.com/watch?time_continue=156&v=wb9jggHEvgI&feature=emb_logo  
Let's say you wanted to test a function that finds the nearest perfect square less than or equal to a certain number. Your first approach might be testing it interactively in a terminal or Jupyter notebook, like this. So first, we'll import the function from the file, and now, we'll start testing it with different values. So let's try five, that should return four since that's the nearest perfect square less than or equal to it. Let's try negative number, which should return zero, which does. Now, let's try an actual perfect square, nine which should return nine, and let's just try another one, 23 that returns 16. So awesome. While this does test the function, it's still a poor way to test because it isn't repeatable, requires you to type these in manually, and doesn't tell you whether it's returning the correct answers. Imagine you have hundreds of functions you need to test and test repeatedly while iterating on your project, you can see how inefficient and unreliable of a method this approach would be for that. After this, you may consider putting your test code into a file to make it repeatable, and end up writing this. This is better because your test code is now on a file that you can run to repeat the same tests without much work, but it's still not telling you whether it's getting the right answers. You'd still have to check, five, the last one's four, that's correct, negative 12, oh yeah, that's zero. Still pretty slow. If we print the correct expected result with each answer, now, we do have a clear way to check out the results. However, we still need to check these results manually to compare what they returned and the correct answer yourself. This is not ideal if we're running a large amount of unit tests often. We can use assert to ensure that each result is identical to the correct answer. This is much better since it checks our results automatically. However, look what happens when something fails. Let's say, I didn't put this equal sign and I only put a less than sign. The result is messy and it stops the program. Ideally, running a test should run all the unit tests and let you know which ones failed and which ones succeeded. This can't happen if it stops with every failure. Any tests that happened after this one failed, we can't see the results of. In addition, the message where failure is messier than it needs to be. Fortunately, there are great tools available in Python that we will use to create effective unit tests.
